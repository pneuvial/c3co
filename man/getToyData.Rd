% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/getToyData.R
\name{getToyData}
\alias{getToyData}
\title{Create a toy subclone and mixture data set}
\usage{
getToyData(n, len, nbClones, nbBkps, eps, weightSparsity = 0.1,
  intercept = TRUE)
}
\arguments{
\item{n}{The number of observations}

\item{len}{The number of loci in each subclone}

\item{nbClones}{The number of subclones}

\item{nbBkps}{The total number of breakpoints}

\item{eps}{A numeric value, the signal to noise ratio for simulated data.}

\item{weightSparsity}{A numeric value in \code{[0,1]}: weights under 
\code{weightSparsity} are set to 0. This parameter controls the sparsity of
the weight matrix.}

\item{intercept}{A logical value indicating whether an intercept should be added (this corresponds to the presence of o normal subclone)}
}
\value{
A list with three elements: \code{W}, a \code{n} x \code{nbClones}
  matrix of weights, and  \code{locus} and \code{segment}, which contain
  locus-level and segment-level data. Each of them is a list of two
  elements: \describe{
  
  \item{Y}{A \code{n} x \code{len} (or \code{nbBkp+1}) matrix of noisy 
  observations}
  
  \item{Z}{A \code{nbClones} x \code{len}  (or \code{nbBkp+1}) matrix of 
  latent features (subclones)}
  
  }
}
\description{
Create a toy subclone and mixture data set
}
\details{
For simplicity, the breakpoints positions are drawn uniformly from 
  the set of all possible positions.
}
\examples{

len <- 100
nbClones <- 2
nbBkps <- 5
n <- 4

dat <- getToyData(n, len, nbClones, nbBkps, eps=0)  ## noiseless
matplot(t(dat$locus$Y), t='s')
matplot(t(dat$segment$Y), t='s')

dat <- getToyData(n, len, nbClones, nbBkps, eps=0.2)  ## noisy
matplot(t(dat$locus$Y), t='l')
matplot(t(dat$segment$Y), t='s')

len <- 1000
nbClones <- 5
nbBkps <- 10
eps <- 1
n <- 20

dat <- getToyData(n, len, nbClones, nbBkps, eps=0)  ## noiseless
matplot(t(dat$locus$Y), t='s')
matplot(t(dat$segment$Y), t='s')

dat <- getToyData(n, len, nbClones, nbBkps, eps=0.2)  ## noisy
matplot(t(dat$locus$Y), t='l')
matplot(t(dat$segment$Y), t='s')

l1 <- seq(from=1e-6, to=1e-4, length.out=10)
parameters.grid <- list(lambda=l1, nb.arch=2:9)

Y <- dat$segment$Y
fit <- fitC3co(Y, parameters.grid=parameters.grid)
pvePlot2(fit$config$best)

}
