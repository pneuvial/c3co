---
title: "c3co"
author: "Morgane Pierre-Jean, Julien Chiquet, Henrik Bengtsson and Pierre Neuvial"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: c3co.bib
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEncoding{UTF-8}
---

## Introduction

The `c3co` package implements a constrained dictionary learning problem to recover cancer subclones from several DNA copy number profiles described in @pierre-jean:c3co. The c3co model may be seen as an extension of the FLLat method of @nowak2011fused, and of the e-FLLat method of @masecchia2013dictionary, with the following original features:

* **interpretable weights**: we model each profile as a *convex combination* of latent profiles, making the corresponding weights directly interpretable as proportions of latent features;
* **parent-specific copy numbers**: we leverage the allelic signals available from SNP array or sequencing data in order to explicitly integrate parent-specific copy numbers (Olshen *et al*, 2011) in the model. 
* **segment-level**: we model tumor clonality at the level of copy number segments (not individual loci), which is the level of information at which such events occur.

Notes: 

* Although the c3co model is designed to deal with allelic signals, we emphasize that it is also applicable to data where only total copy number estimates are available, such as array-CGH data or low-pass sequencing data.

* The FLLat method is implemented in the R package `FLLat`. The e-FLLat method is implemented in Python and is available from its authors.

## Model 

The figure below illustrates the model used in the `c3co` package. Two heterogeneous tumor samples (green and yellow circles) are composed of a collection of normal cells (gray discs) and two cancer subclones (red triangles and blue squares). One of the cancer subclones is present in both tumor samples. 

![](img/features.png)
![](img/features2.png)

The corresponding (noiseless) copy number profiles are displayed in the figure below. They are given by a linear combination of the latent profiles. This Figure is adapted from @nowak2011fused.

![](img/model.png)
![](img/model2.png)


## Using the package
```{r, message=FALSE,warning=FALSE}
stopifnot(packageVersion("acnr") >= '0.2.6')
library("c3co")
library("ggplot2")
library("mclust")
library("reshape")
set.seed(147)
```

### Creating a synthetic data set

We start by defining the characteristics of the subclone profiles: profile length, number of subclones, breakpoint positions, and copy number states:

```{r}
len <- 700*10
nbClones <- 2
bkps <- list(
    c(20, 30, 50, 60)*100, 
    c(10, 40, 60)*100)
regions <- list(
    c("(1,1)", "(1,2)", "(1,1)", "(0,1)", "(1,1)"),
    c("(0,1)", "(1,1)", "(1,2)", "(1,1)"))
```

Then, we simulate the subclone profiles with the above characteristics:

```{r}
datSubClone <- buildSubclones(len, nbClones, bkps, regions, eps=0.5)
```
 
 
```{r, echo=FALSE}
cols <- c("#AAAAAA33", "#00000099", "#AAAAAA33")
cex <- 0.3
pch <- 19 
clim <- c(0, 4)
blim <- c(-0.1, 1.1)
sc <- datSubClone[[1]]
plot(sc$ct, col=cols[factor(sc$genotype)], cex=cex, pch=pch, ylab="TCN", ylim=clim, main="PSCN profile of one simulated subclone")
plot(sc$baft, col=cols[factor(sc$genotype)], cex=cex, pch=pch, ylab="BAF", ylim=blim)
```

Once the subclones are created, we can generate a weight matrix $W$ in order to build mixtures.

```{r, warning=FALSE, cache=FALSE}
W <-  rSparseWeightMatrix(5, nbClones, 0.7)
datList <- mixSubclones(subClones=datSubClone, W)
str(datList[[1]])
```

Note that `datList` is a list of data frames with the following required columns : `c1,c2,tcn,dh,genotype`

### Inference of the c3co model parameters

Then the c3co method can be applied to the mixture data set. Let us choose the same grid for $\lambda_1$ and $\lambda_2$ and a grid from 2 to 6 for the number of subclones.

```{r c3co, warning=FALSE, message=FALSE}
l1 <- seq(from=1e-8, to=1e-5, length.out=10)
nb.arch <- 2:5
parameters.grid <- list(lambda1=l1, nb.arch=nb.arch) 
res <- c3co(datList, parameters.grid, verbose=FALSE, warn=FALSE)
l2 <- seq(from=1e-6, to=1e-3, length.out=5)
parameters.grid <- list(lambda=l2, nb.arch=nb.arch) 
resC <- c3co(datList, parameters.grid, stat="TCN", verbose=FALSE)
```

For each candidate number of subclones $p$ in `r nb.arch`,  `c3co` only retains the combination of the penalization coefficients $(\lambda_1, \lambda_2)$ which minimizes the Bayesian Information Criterion (BIC) of the model. The next step is to choose the best $p$ (number of subclones). Following @nowak2011fused, we compare the models for different values of $p$ through their percentage of variance explained (PVE), and select the last $p$ before the final plateau of the PVE. 

```{r}
pvePlot(res, ylim=c(0.0,1))
```

```{r}
pvePlot(resC, ylim=c(0.0,1))
```

We can compare the true and the estimated weight matrices. We can easily recover a classification close to the truth with the inferred weight matrix. 

```{r heatmap_C1C2, fig.width=7, fig.height=5}
best <- 2
res.clustTRUE <- hclust(dist(cbind(W, 1-rowSums(as.matrix(W)))),method="ward.D")
col <-  grDevices::colorRampPalette(RColorBrewer::brewer.pal(9, 'GnBu'))(100)
Wplot(res, idxBest = best, cexCol = 0.4)
```

```{r heatmap_TCN, fig.width=7, fig.height=5}
Wplot(resC, idxBest = best, cexCol = 0.4)
```

```{r heatmap_TRUE, fig.width=7, fig.height=5}
heatmap.3(cbind(W, 1-rowSums(as.matrix(W))), dendrogram="row", main="TRUE", Rowv=as.dendrogram(res.clustTRUE), col=col,scale="none")
```

If we look at the subclones in the dimension of parental copy numbers, we can recover the simulated alterations.

```{r,Z1Z2hat, fig.width=7.5, fig.height=5}
df <- createZdf(res, chromosomes=1, idxBest = best)
Zplot(df)
```

## Further analysis
### Performance  of clustering
In this section, we show the ablility of the method to recover the simulated clustering of patients.

```{r,clust}
WC1C2 <- res@fit[[best]]@W
WTCN <- resC@fit[[best]]@W
Wtrue <- cbind(W, 1-rowSums(as.matrix(W)))
adjustedRandIndex(cutree(hclust(dist(WC1C2), method="ward.D2"),4), cutree(hclust(dist(Wtrue), method="ward.D2"),4))
adjustedRandIndex(cutree(hclust(dist(WTCN), method="ward.D2"),4), cutree(hclust(dist(Wtrue), method="ward.D2"),4))
```
## Performance of alteration detection
In this section, we show the ablility of the method to recover the simulated altered regions.

```{r, fig.width=7.5, fig.height=5}
getAlteredSegments <- function(tol, zz1, zz2, c1Mean, c2Mean){
  loss <- ((c1Mean-zz1) >= tol)| ((c2Mean-zz2) >= tol)
  gain <- ((zz2 - c2Mean) >= tol)|((zz1-c1Mean) >= tol)
  ## coding gains as 3
  gain <- apply(gain, 2, function (gg) {
    idx <- which(gg)
    gg[idx] <- 3
    return(gg)
  })
  ## coding loh segments as 4 (gain + loss)
  pos <- loss+gain
  return(pos)
}

dataBest <- res@fit[[best]]
meanMin <- mean(df$CopyNumber[which(df$arch=="d"&df$stat=="Minor")])
getAlt <- getAlteredSegments(tol=0.2, dataBest@S$Z1, dataBest@S$Z2, 1, 1.1)
colnames(getAlt) <- sprintf("Subclone %s", letters[1:ncol(dataBest@W)])
df.Alt <- reshape::melt(getAlt)
df.Alt$x.min <- rep(res@bkp[[1]][-length(res@bkp[[1]])], best+1)
df.Alt$x.max <- rep(res@bkp[[1]][-1], best+1)
ggplot(df.Alt, aes(xmin = x.min, xmax = x.max, ymin = 1, ymax =2, fill = factor(value))) + geom_rect() + facet_grid(X2~.)+theme(axis.text.y = element_blank(), axis.ticks = element_blank())+scale_fill_discrete(labels= c("Normal", "Loss", "Gain", "LoH"), name="States")
```

## Session information

```{r}
sessionInfo()
```

## References


